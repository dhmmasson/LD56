{"version":3,"file":"lilyFrog.js","mappings":";;;;;;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA,aAAa,QAAQ;AACrB,cAAc,cAAc;AAC5B,cAAc,0DAA0D;AACxE,cAAc,QAAQ;AACtB,cAAc,0BAA0B;AACxC,cAAc,gBAAgB;AAC9B,cAAc,kEAAkE;AAChF,cAAc,SAAS;AACvB;;AAEA;AACA;AACA,WAAW,gBAAgB;AAC3B,WAAW,MAAM;AACjB;AACA;AACA;AACA;AACA,aAAa;AACb,GAAG;AACH;;AAEA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,cAAc;AACzB,aAAa,QAAQ;AACrB;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,QAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,iBAAiB;AAC5B,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;;;AC/PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA,cAAc,sDAAsD;AACpE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2BAA2B,sBAAsB;AACjD,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,sBAAsB;AACnD,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,MAAM;AAChD,KAAK;AACL;AACA;AACA;AACA,wCAAwC,MAAM;AAC9C,KAAK;AACL;AACA;;;;;;;;;ACxVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA","sources":["webpack://lily-frogs/./src/diagram.js","webpack://lily-frogs/./src/sketch.js","webpack://lily-frogs/./src/ui.js"],"sourcesContent":["const dhmdist = (p1, p2) => dist(p1.x, p1.y, p2.x, p2.y);\n\nfunction generateDiagram() {\n  let diagram = null;\n  diagram = relaxDiagram(null, 100);\n  diagram = subdivide(diagram);\n  return diagram;\n}\n\nfunction drawDiagram() {\n  if (Game.board.diagram) {\n    // Draw the quads\n    stroke(colors[\"Midnight green\"]);\n    strokeWeight(1);\n    noFill();\n    Game.board.diagram.quads.forEach((quad) => {\n      drawConnection(quad, 0, color(colors[\"Celestial Blue\"]));\n    });\n    Game.board.diagram.quads.forEach((quad) => {\n      drawQuad(quad, color(colors[\"Mint\"]));\n    });\n  }\n}\n\n/**\n * @typedef {Object} Quad\n * @property {Voronoi.Cell} cell - The Voronoi cell associated with the quad.\n * @property {[Voronoi.Edge, Voronoi.Edge, Voronoi.Edge, Voronoi.Edge]} edges - The four edges that form the quad.\n * @property {number} id - The unique identifier for the quad.\n * @property {[Quad, Quad, Quad, Quad]} neighbours - The four neighboring quads.\n * @property {Voronoi.Vertex} site - The Voronoi vertex (site) associated with the quad.\n * @property {[Voronoi.Vertex, Voronoi.Vertex, Voronoi.Vertex, Voronoi.Vertex]} vertices - The four vertices of the quad.\n * @property {boolean} removed - Whether the quad has been removed.\n */\n\n/**\n * Check if a point (the mouse) is inside a quad.\n * @param {Voronoi.Vertex} point\n * @param {Quad} quad\n * @returns boolean\n */\nfunction isPointInQuad(point, quad) {\n  const vertices = quad.vertices.map((v) => {\n    return { x: v.x * Game.board.size.width, y: v.y * Game.board.size.height };\n  });\n  let totalAngle = 0;\n\n  // Loop through each pair of consecutive vertices (forming vectors to the point)\n  for (let i = 0; i < vertices.length; i++) {\n    const v1 = createVector(vertices[i].x - point.x, vertices[i].y - point.y);\n    const v2 = createVector(\n      vertices[(i + 1) % vertices.length].x - point.x,\n      vertices[(i + 1) % vertices.length].y - point.y\n    );\n    const angle = v1.angleBetween(v2);\n    totalAngle += angle;\n  }\n\n  return Math.abs(totalAngle) > Math.PI;\n}\n\n/**\n * Compute and update the centroid of a cell.\n * Return the distance between the centroid and the site (seed of the cell).\n * @param {Voronoi.Cell} cell\n * @returns {number} The distance between the centroid and the site.\n */\nfunction computeCentroid(cell) {\n  cell.centroid = { x: 0, y: 0 };\n  cell.halfedges.forEach((halfedge) => {\n    const v = halfedge.getStartpoint();\n    cell.centroid.x += v.x;\n    cell.centroid.y += v.y;\n  });\n  cell.centroid.x /= cell.halfedges.length;\n  cell.centroid.y /= cell.halfedges.length;\n\n  return dhmdist(cell.centroid, cell.site);\n}\n\n/**\n * Compute all the centroids of the cells in the diagram, and return the total distance between the centroids and the sites of all cells.\n * @returns {number} The total distance between the centroids and the sites of all cells.\n */\nfunction computeCentroids() {\n  return Game.board.diagram.cells.reduce(\n    (totalDistance, cell) => totalDistance + computeCentroid(cell),\n    0\n  );\n}\n\n/**\n * Subdivide the diagram into quads.\n * @param {Voronoi.Diagram} diagram\n * @returns {Voronoi.Diagram} The diagram with the quads.\n * */\nfunction subdivide(diagram) {\n  let quads = [];\n  const edges = [];\n  const vertices = diagram.vertices.slice() || [];\n\n  // Generate edges from the voronoi edges\n  // cut existing edges in half\n  // generate edges from the site to the middle of the voronoi edges\n  // Store them in the original edges for easy access when subdividing\n  for (const edge of diagram.edges) {\n    va = edge.va;\n    vb = edge.vb;\n    let middle = new Voronoi.prototype.Vertex(\n      (va.x + vb.x) / 2,\n      (va.y + vb.y) / 2\n    );\n    vertices.push(middle);\n    edge.middlePoint = middle;\n\n    // First half of the perimeter\n    let edgeFirstHalf = new Voronoi.prototype.Edge(edge.lSite, edge.rSite);\n    edgeFirstHalf.va = va;\n    edgeFirstHalf.vb = middle;\n    edges.push(edgeFirstHalf);\n    // Second half of the perimeter\n    let edgeSecondHalf = new Voronoi.prototype.Edge(edge.rSite, edge.lSite);\n    edgeSecondHalf.va = middle;\n    edgeSecondHalf.vb = vb;\n    edges.push(edgeSecondHalf);\n\n    edge.daughters = [edgeFirstHalf, edgeSecondHalf];\n\n    // From the center of the cell to the middle of the edge\n    let edgeMiddleLeft = new Voronoi.prototype.Edge(edge.lSite, edge.lSite);\n    edgeMiddleLeft.va = edge.lSite;\n    edgeMiddleLeft.vb = middle;\n    edges.push(edgeMiddleLeft);\n    edge.middleEdges = [edgeMiddleLeft];\n\n    //if there is a right site\n    if (edge.rSite) {\n      let edgeMiddleRight = new Voronoi.prototype.Edge(edge.rSite, edge.rSite);\n      edgeMiddleRight.va = edge.rSite;\n      edgeMiddleRight.vb = middle;\n      edges.push(edgeMiddleRight);\n      edge.middleEdges.push(edgeMiddleRight);\n    }\n  }\n\n  // Each edge will reference the two quad on either side\n  edges.forEach((edge) => {\n    edge.quad = [];\n  });\n\n  for (const cell of diagram.cells) {\n    vertices.push(cell.site);\n    let cellVertices = [];\n    let va;\n    //split the edges\n\n    let perimterEdges = [];\n    let insideEdges = [];\n\n    // Generate the quads\n\n    for (const halfedge of cell.halfedges) {\n      va = halfedge.getStartpoint();\n      vb = halfedge.getEndpoint();\n      middle = halfedge.edge.middlePoint;\n      if (halfedge.site === halfedge.edge.lSite) {\n        perimterEdges.push(halfedge.edge.daughters[0]);\n        perimterEdges.push(halfedge.edge.daughters[1]);\n      } else {\n        perimterEdges.push(halfedge.edge.daughters[1]);\n        perimterEdges.push(halfedge.edge.daughters[0]);\n      }\n\n      if (halfedge.edge.lSite === cell.site) {\n        insideEdges.push(halfedge.edge.middleEdges[0]);\n        insideEdges.push(halfedge.edge.middleEdges[0]);\n      } else {\n        insideEdges.push(halfedge.edge.middleEdges[1]);\n        insideEdges.push(halfedge.edge.middleEdges[1]);\n      }\n\n      cellVertices.push(va);\n      cellVertices.push(middle);\n    }\n    // Add the last vertex // same as tht first\n    cellVertices.push(cellVertices.shift());\n    perimterEdges.push(perimterEdges.shift());\n    insideEdges.push(insideEdges.shift());\n    // duplicate the first middle\n    cellVertices.push(cellVertices[0]);\n\n    while (cellVertices.length > 1) {\n      let vertices = [\n        cell.site, // center\n        cellVertices.shift(), //middle\n        cellVertices.shift(), //corner\n        cellVertices[0], // next middle (keep for next quad)\n      ];\n      let quad = {\n        site: vertices.reduce(\n          (acc, v) => {\n            acc.x += v.x / 4;\n            acc.y += v.y / 4;\n            return acc;\n          },\n          { x: 0, y: 0 }\n        ),\n        edges: [\n          insideEdges.shift(),\n          perimterEdges.shift(),\n          perimterEdges.shift(),\n          insideEdges.shift(),\n        ],\n        vertices,\n        cell,\n      };\n\n      // Register the quad to the edge\n      quad.edges.forEach((edge) => {\n        edge.quad.push(quad);\n      });\n      quad.lilyPad = random(Game.assets.lilypads);\n      quads.push(quad);\n    }\n  }\n\n  // Define the neighbour by looking at the edges\n  quads.forEach((quad, i) => {\n    quad.id = i;\n    quad.neighbours = quad.edges.map((edge) => {\n      return edge.quad.filter((q) => q !== quad)[0];\n    });\n  });\n\n  diagram.quads = quads;\n  diagram.dhmEdges = edges;\n  return diagram;\n}\n\nfunction relaxDiagram(diagram, maxIterations) {\n  let temp = 10;\n  while (temp > 0.1 && maxIterations-- > 0) {\n    voronoi.recycle(Game.board.diagram);\n    diagram = Game.board.diagram = voronoi.compute(Game.board.sites, {\n      xl: 0,\n      xr: 1,\n      yt: 0,\n      yb: 1,\n    });\n    temp = computeCentroids();\n    Game.board.sites = diagram.cells.map((cell) => {\n      return cell.centroid;\n    });\n  }\n  return diagram;\n}\n","colors = {\n  \"Midnight green\": \"#005f73\",\n  \"Dark cyan\": \"#0a9396\",\n  Mint: \"#61bd9e\",\n  Vanilla: \"#e9d8a6\",\n  Gamboge: \"#e99700\",\n  \"Cocoa Brown\": \"#de7002\",\n  Tawny: \"#cb5f12\",\n  \"Engineering orange\": \"#b92113\",\n  \"Penn red\": \"#9d1b12\",\n  \"Falu red\": \"#7a1815\",\n  // \"Midnight green\": \"#1d5267\",\n  \"Celestial Blue\": \"#0f9ad2\",\n  \"Pale azure\": \"#6cd4ff\",\n  \"Cosmic latte\": \"#fff9eb\",\n  \"Persian pink\": \"#fe7fd1\",\n  \"Deep pink\": \"#ff1499\",\n  \"Magenta dye\": \"#b80068\",\n};\n\n/** Levels */\nconst voronoi = new Voronoi();\nconst Levels = {\n  tutorial: {\n    level: 0,\n    title: \"Tutorial\",\n    board: {\n      sites: [],\n    },\n  },\n};\n\n/** MENUS */\nconst mainMenuStruct = {\n  buttons: [{ label: \"Start Game\", action: startGame, handle: null }],\n  title: \"Main Menu\",\n  buttonSize: 200,\n  buttonSpacing: 10,\n};\n\nconst GameStates = {\n  menu: \"menu\",\n  playing: \"playing\",\n};\n\nconst Game = {\n  level: Levels.tutorial,\n  state: \"menu\",\n  currentLevel: 0,\n  board: {\n    size: {\n      width: 100,\n      height: 100,\n    },\n    sites: [], // Voronoi\n    diagram: null,\n  },\n  menus: {\n    main: mainMenuStruct,\n  },\n  currentMenu: \"\",\n  nextMenu: \"main\",\n};\n\n/** */\nfunction startGame() {\n  console.log(\"Start Game\");\n  Game.board.sites = Array(14)\n    .fill({ x: 0, y: 0 })\n    .map((site, index) => {\n      return {\n        x: constrain((noise(0, index) - 0.5) * 2 + 0.5, 0.001, 0.999),\n        y: constrain((noise(1, index) - 0.5) * 2 + 0.5, 0.001, 0.999),\n      };\n    });\n\n  let diagram = generateDiagram();\n  diagram.quads\n    .filter((e) => e.neighbours.filter((e) => e).length !== 4)\n    .forEach((e) => {\n      e.removed = true;\n    });\n  console.log(diagram);\n  Game.state = GameStates.playing;\n  Game.currentPlayer = 0;\n  Game.players = [\n    {\n      color: colors[\"Persian pink\"],\n      frog: Game.assets.frog_pink,\n      frogs: [\n        {\n          quad: diagram.quads[10],\n          direction: 0,\n        },\n      ],\n    },\n    {\n      color: colors[\"Pale azure\"],\n      frog: Game.assets.frog_blue,\n      frogs: [\n        {\n          quad: diagram.quads[20],\n          direction: 2,\n        },\n      ],\n    },\n  ];\n}\n\nfunction drawDiagram() {\n  if (Game.board.diagram) {\n    // Draw the quads\n    stroke(colors[\"Midnight green\"]);\n    strokeWeight(1);\n    noFill();\n    Game.board.diagram.quads.forEach((quad) => {\n      drawConnection(quad, 0, color(colors[\"Celestial Blue\"]));\n    });\n    Game.board.diagram.quads.forEach((quad) => {\n      drawQuad(quad, color(colors[\"Mint\"]));\n    });\n  }\n}\n\nfunction drawGame() {\n  if (Game.state !== GameStates.playing) {\n    return false;\n  }\n  drawDiagram();\n  drawFrogs();\n}\n\nfunction drawFrogs() {\n  Game.players.forEach((player) => {\n    player.frogs.forEach((frog) => {\n      drawFrog(player, frog);\n    });\n  });\n}\n\nfunction drawFrog(player, frog) {\n  let quad = frog.quad;\n  if (frog.higlighted || frog.selected) {\n    frog.higlighted = false;\n    tint(player.color);\n    image(\n      Game.assets.frog_halo,\n      quad.site.x * Game.board.size.width,\n      quad.site.y * Game.board.size.height - 16,\n      36,\n      36\n    );\n    noTint();\n  }\n  image(\n    player.frog,\n    quad.site.x * Game.board.size.width,\n    quad.site.y * Game.board.size.height - 16,\n    32,\n    32\n  );\n}\n\nfunction setup() {\n  // Create canvas and put it in the canvas div to guess the size\n  imageMode(CENTER);\n\n  createCanvas(Game.board.size.width, Game.board.size.height).parent(\"#canvas\");\n  windowResized();\n\n  startGame();\n}\n\nfunction mouseClicked() {\n  let frog = getFrog();\n  let quad = getQuad();\n  if (frog && !frog.selected) {\n    if (Game.currentFrog) Game.currentFrog.selected = false;\n    Game.currentFrog = frog;\n    frog.selected = true;\n  } else if (frog && frog.selected) {\n    frog.selected = false;\n    Game.currentFrog = null;\n  } else {\n    if (Game.currentFrog) {\n      frog = Game.currentFrog;\n      // Remove the quad under the frog\n      frog.quad.removed = true;\n      // Move the Frog to the quad\n      frog.quad = quad;\n      Game.currentFrog = null;\n      frog.selected = false;\n      // Change the player\n      Game.currentPlayer = (Game.currentPlayer + 1) % Game.players.length;\n    }\n  }\n}\n\nfunction getQuad() {\n  return (quad = Game.board.diagram.quads.find((quad) => {\n    return isPointInQuad({ x: mouseX, y: mouseY }, quad);\n  }));\n}\n\nfunction getFrog() {\n  let quad = getQuad();\n  if (quad) {\n    return Game.players[Game.currentPlayer].frogs.find((frog) => {\n      return frog.quad === quad;\n    });\n  } else {\n    return null;\n  }\n}\n\nfunction draw() {\n  background(colors[\"Midnight green\"]);\n  displayMenu();\n\n  // Draw the mouse\n  fill(0);\n  ellipse(mouseX, mouseY, 5, 5);\n  // find the quad\n  if (Game.board.diagram) {\n    let quad = Game.board.diagram.quads.find((quad) => {\n      return isPointInQuad({ x: mouseX, y: mouseY }, quad);\n    });\n    if (quad) {\n      drawQuad(quad, color(colors[\"Cosmic latte\"]));\n      quad.traversed = true;\n      followQuad(quad, 0, color(colors[\"Persian pink\"]));\n      followQuad(quad, 2, color(colors[\"Persian pink\"]));\n      cleanBoard();\n      followQuad(quad, 1, color(colors[\"Pale azure\"]));\n      followQuad(quad, 3, color(colors[\"Pale azure\"]));\n      cleanBoard();\n      //Find the frog\n      let [frog] = Game.players[Game.currentPlayer].frogs.filter(\n        (frog) => frog.quad === quad\n      );\n      if (frog) {\n        frog.higlighted = true;\n      }\n      if (mouseIsPressed) {\n      }\n    }\n    drawGame();\n\n    // Draw the connected quads\n  }\n\n  // untraverse the quads\n}\n\nfunction cleanBoard() {\n  Game.board.diagram.quads.forEach((quad) => {\n    quad.traversed = false;\n  });\n}\nfunction drawConnection(quad, direction, color) {\n  if (quad.removed) {\n    return false;\n  }\n  fill(\"#61bd9e\");\n  strokeWeight(2);\n  stroke(color);\n  quad.neighbours.forEach((neighbour) => {\n    if (neighbour && !neighbour.removed) {\n      stroke(\"#61bd9e\");\n      strokeWeight(2);\n      line(\n        quad.site.x * Game.board.size.width,\n        quad.site.y * Game.board.size.height,\n        neighbour.site.x * Game.board.size.width,\n        neighbour.site.y * Game.board.size.height\n      );\n    }\n  });\n}\nfunction drawQuad(quad, color) {\n  if (quad.removed) {\n    return false;\n  }\n  // stroke(0);\n  strokeWeight(1);\n\n  noFill();\n  // beginShape();\n  // quad.vertices.forEach((v) => {\n  //   vertex(v.x * Game.board.size.width, v.y * Game.board.size.height);\n  // });\n  // endShape(CLOSE);\n  let radius =\n    quad.neighbours.reduce((acc, neighbour) => {\n      return min(acc, dhmdist(neighbour.site, quad.site));\n    }, 1000) * 0.89;\n  fill(color);\n  stroke(\"#429e80\");\n  // ellipse(\n  //   quad.site.x * Game.board.size.width,\n  //   quad.site.y * Game.board.size.height,\n  //   radius * Game.board.size.width,\n  //   radius * Game.board.size.height\n  // );\n  // Draw a lilypad\n  image(\n    quad.lilyPad,\n    quad.site.x * Game.board.size.width,\n    quad.site.y * Game.board.size.height,\n    radius * Game.board.size.width,\n    radius * Game.board.size.height\n  );\n}\n\nfunction followQuad(quad, direction, color) {\n  let nextQuad = quad.neighbours[direction];\n  if (!nextQuad || nextQuad.removed) {\n    return false;\n  }\n  let nextDirection = //find in the nextQuad where we come from\n    (nextQuad.neighbours.findIndex((neighbour) => neighbour === quad) + 2) % 4;\n\n  if (nextQuad && !nextQuad.traversed) {\n    drawQuad(nextQuad, color);\n    nextQuad.traversed = true;\n    followQuad(nextQuad, nextDirection, color);\n  }\n}\n\nfunction preload() {\n  Game.assets = {};\n  Game.assets.frog_blue = loadImage(\"./assets/frog-blue.png\");\n  Game.assets.frog_pink = loadImage(\"./assets/frog-pink.png\");\n  Game.assets.lilypads = Array(2)\n    .fill()\n    .map((_, i) => {\n      return loadImage(`./assets/lilypad${i + 1}.png`);\n    });\n  Game.assets.lotus = Array(4)\n    .fill()\n    .map((_, i) => {\n      return loadImage(`./assets/lotus${i + 1}.png`);\n    });\n  Game.assets.frog_halo = loadImage(\"./assets/frog-halo.png\");\n}\n","//Resize canvas to fill the div\nfunction windowResized() {\n  const size = select(\"#canvas\").size();\n  // Square Board\n  let minSize = min(size.width, size.height);\n  Game.board.size.width = minSize;\n  Game.board.size.height = minSize;\n  resizeCanvas(minSize, minSize);\n  // Force Menu refresh\n  Game.currentMenu = \"\";\n}\n\nfunction touchMoved() {\n  // do some stuff\n  return false;\n}\n\nfunction initMenu(menu) {\n  // Display the main menu\n  gui = createGui();\n  // gui.setTitle(menu.title);\n  let y = 50;\n  menu.buttons.forEach((button) => {\n    button.handle = createButton(\n      button.label,\n      Game.board.size.width / 2 - menu.buttonSize / 2,\n      y,\n      menu.buttonSize\n    );\n    y += menu.buttonSize + menu.buttonSpacing;\n  });\n  return gui;\n}\n\nfunction checkButtons() {\n  Game.menus[Game.currentMenu].buttons.forEach((button) => {\n    if (button.handle.isPressed) {\n      button.action();\n    }\n  });\n}\n\nfunction displayMenu() {\n  //Only display the menu if the game is in the menu state\n  if (Game.state !== GameStates.menu) {\n    return false;\n  }\n  // Create the menu on menu change\n  if (Game.currentMenu !== Game.nextMenu) {\n    initMenu(Game.menus[Game.nextMenu]);\n    Game.currentMenu = Game.nextMenu;\n  }\n\n  background(colors[\"Midnight green\"]);\n  drawGui();\n\n  // Check if buttons are pressed\n  checkButtons();\n}\n"],"names":[],"sourceRoot":""}